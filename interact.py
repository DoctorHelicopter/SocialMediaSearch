import praw
from flask import g
import pandas as pd
from datetime import datetime
import smtplib
def run_search(qlist):
    results = []
    #take in a list of queries and dispatch other functions
    for q in qlist:
        query = g.db.execute("select * from QUERIES where QID=?",(q,)).fetchall()[0]
        if q[2] == 'reddit':
            results+=get_reddit(q)
        elif q[2] == 'facebook':
            results+=get_facebook(q)
        elif q[2] == 'twitter':
            results+=get_twitter(q)
        elif q[2] == 'instagram':
            results+=get_instagram(q)
    return results

def get_reddit(q):
    usr = 'myapitester' #I created an account for this, feel free to use whatever
    pwd = 'password'
    red = praw.Reddit(user_agent="python:socialmediasearch:v0.1 (by /u/myapitester)")
    red.login(usr,pwd)
    results = []
    done = []
    kw = q[3]
    has_kw = any(kw.lower() in word for word in submission.selftext.lower())
    #run a search for all matching posts
    for submission in red.search(kw):
        if submission.id not in done and has_kw:
            link = submission.short_link
            done.append(submission.id)
            results.append(submission)
            #for each match, write it to the result database
            g.db.execute("insert into RESULTS (RID,QID,DATE_RUN,SITE,TITLE,LINK,MATCH_KEYWORDS) values (?,?,datetime('now','localtime'),'reddit',?,?,?)",(str(uuid4()),q[0],submission.title,submission.short_link,kw))
            g.db.commit()
    return results

#######
#These functions need to be built out to actually work
#I didn't get to them; not enough time.
def get_facebook(q):
    results = []
    return results

def get_twitter(q):
    results = []
    return results

def get_instagram(q):
    results = []
    return results
#######

def create_csv(results):
    #take a list of result IDs
    if len(results) > 0:
        df = pd.read_sql_query("select * from RESULTS where RID in (?)",(', '.join(["'"+r+"'" for r in results])),g.db)
        filename = 'static/media/result_%s.csv' % datetime.now().strftime('%Y%m%d%H%M%S') #timestamp? why not?
    else: #sometimes (most of the time, with the current code) there will be no results...that should be indicated in the file
        df = pd.DataFrame().from_dict([{'RESULT':'No results found'}])
        filename = 'static/media/no_results_%s.csv' % datetime.now().strftime('%Y%m%d%H%M%S')
    #create the csv
    df.to_csv(filename,index=False)
    #return the filepath
    return filename

def send_email(f,dest):
    #take a filepath and list of recipients
    #connect to your desired email box
    #I used gmail for simplicity, but I could substitute whatever
    usr = '*****@gmail.com' #enter your own credentials here
    pwd = '*****'
    srv = 'smtp.gmail.com:587'
    mail = smtplib.SMTP(srv)
    mail.ehlo()
    mail.starttls()
    mail.login(usr,pwd)
    text = 'Attached is the file generated at %s for your query.' % datetime.strptime(f.split('_')[1].split('.')[0],'%Y%m%d%H%M%S').strftime('%m/%d/%Y %H:%M:%S') #This is such an ugly method but I suppose it works.
    text += ' Please submit a support ticket if you experience any issues.'
    #write the message, attach the file
    msg = MIMEMultipart(
        From=usr,
        To=COMMASPACE.join(dest),
        Date=formatdate(localtime=True),
        Subject='Results generated by server %s' % socket.gethostname() #I usually denote server name in the subject so users know where it's coming from - test, or production, or whatever
    )
    msg.attach(MIMEText(text))

    with open(f, "rb") as attach:
        msg.attach(MIMEApplication(
            attach.read(),
            Content_Disposition='attachment; filename="%s"' % basename(f),
            Name=basename(f)
        ))
    #send the email to the given list of recipients
    mail.sendmail(usr,dest,msg.as_string())
    mail.close()
